name: Update EPG

on:
  schedule:
    - cron: '*/30 * * * *'
  workflow_dispatch:

jobs:
  update-epg:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v3
      
    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
        
    - name: Install dependencies
      run: pip install requests
      
    - name: Download and merge EPG
      run: |
        python3 << 'EOF'
        import requests
        import xml.etree.ElementTree as ET
        import gzip
        import time
        from datetime import datetime
        
        EPG_URLS = [
            "https://myepg.top/?download_file=35078&order=wc_order_4oJUv9UXzRLoN&email=8ktv.tv%40gmail.com&key=e80183e4-2386-4f14-9a9f-426ba743864e",
            "https://myepg.top/?download_file=35078&order=wc_order_4oJUv9UXzRLoN&email=8ktv.tv%40gmail.com&key=9dc267c7-0de7-4198-9387-5d69a7deb4a0"
        ]
        
        def download_and_decompress(url, max_retries=3):
            """Télécharge et décompresse un fichier EPG avec retry"""
            for attempt in range(max_retries):
                try:
                    timeout = 120 + (attempt * 30)
                    print(f"Downloading {url[:50]}... (attempt {attempt + 1}/{max_retries}, timeout={timeout}s)")
                    
                    response = requests.get(url, timeout=timeout, stream=True)
                    response.raise_for_status()
                    content = response.content
                    
                    if content[:2] == b'\x1f\x8b':
                        print(f"Decompressing gzip file...")
                        content = gzip.decompress(content)
                    
                    size_mb = len(content) / 1024 / 1024
                    print(f"Downloaded {size_mb:.1f} MB")
                    return content
                    
                except Exception as e:
                    print(f"Error on attempt {attempt + 1}: {e}")
                    if attempt < max_retries - 1:
                        time.sleep(10)
                    else:
                        raise
        
        print(f"\nStarting EPG merge at {datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S UTC')}\n")
        
        root = ET.Element("tv")
        root.set("generator-info-name", "epg-auto-merger")
        root.set("generator-info-url", "https://github.com/IPTV-premium/epg-merger-auto")
        
        all_channels = {}
        all_programmes = {}
        
        for i, url in enumerate(EPG_URLS, 1):
            try:
                print(f"\n=== Processing EPG Source #{i} ===")
                content = download_and_decompress(url)
                tree = ET.fromstring(content)
                
                channels_added = 0
                for channel in tree.findall("channel"):
                    channel_id = channel.get("id")
                    if channel_id and channel_id not in all_channels:
                        all_channels[channel_id] = channel
                        channels_added += 1
                
                programmes_added = 0
                for prog in tree.findall("programme"):
                    prog_key = f"{prog.get('channel')}_{prog.get('start')}_{prog.get('stop')}"
                    if prog_key not in all_programmes:
                        all_programmes[prog_key] = prog
                        programmes_added += 1
                
                print(f"EPG #{i}: +{channels_added} channels, +{programmes_added} programmes")
                
            except Exception as e:
                print(f"Failed to process EPG #{i}: {e}")
        
        if not all_channels and not all_programmes:
            raise Exception("No data from any EPG source!")
        
        print(f"\n=== Building final EPG ===")
        for channel in all_channels.values():
            root.append(channel)
        for programme in all_programmes.values():
            root.append(programme)
        
        tree = ET.ElementTree(root)
        ET.indent(tree, space="  ")
        
        with open('merged_epg.xml', 'wb') as f:
            f.write(b'<?xml version="1.0" encoding="UTF-8"?>\n')
            tree.write(f, encoding='utf-8', xml_declaration=False)
        
        import os
        size_mb = os.path.getsize('merged_epg.xml') / 1024 / 1024
        
        print(f"\n=== SUCCESS ===")
        print(f"Channels: {len(all_channels)}")
        print(f"Programmes: {len(all_programmes)}")
        print(f"File size: {size_mb:.1f} MB")
        
        with open('stats.txt', 'w') as f:
            f.write(f"Updated: {datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S UTC')}\n")
            f.write(f"Channels: {len(all_channels)}\n")
            f.write(f"Programmes: {len(all_programmes)}\n")
            f.write(f"Size: {size_mb:.1f} MB\n")
        
        EOF
    
    - name: Compress EPG
      run: |
        gzip -9 -k merged_epg.xml
        ls -lh merged_epg.xml*
        
    - name: Delete old releases
      continue-on-error: true
      uses: dev-drprasad/delete-older-releases@v0.3.2
      with:
        keep_latest: 1
        delete_tags: true
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Get current date
      id: date
      run: echo "date=$(date +'%Y-%m-%d %H:%M UTC')" >> $GITHUB_OUTPUT
        
    - name: Upload to Release
      uses: softprops/action-gh-release@v1
      with:
        tag_name: latest
        name: "Latest EPG - ${{ steps.date.outputs.date }}"
        body: |
          ## EPG mis à jour automatiquement
          
          **Date:** ${{ steps.date.outputs.date }}
          
          ### Téléchargement:
          - `merged_epg.xml` - Version non compressée
          - `merged_epg.xml.gz` - Version compressée (recommandée)
          - `stats.txt` - Statistiques
          
          ### URL directe:
